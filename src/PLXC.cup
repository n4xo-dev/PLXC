import java_cup.runtime.*;
import java.lang.String;
import java.util.HashMap;
import java.util.ArrayList;
import AST.*;

// parser code {:
// 	public void syntax_error(Symbol cur_token){
// 	}

// 	public void unrecovered_syntax_error(Symbol cur_token){
// 		System.err.println( "Syntax error:"  );
// 		// report_error("Syntax error", null);
// 		done_parsing();
// 	}
// :};


// Terminales
terminal String SEMICOLON, COMA;
terminal String O_PAR, C_PAR, O_CURL, C_CURL, O_BRACK, C_BRACK;
terminal String PLUS, MINUS, MULT, DIV, MOD, MINUS_SIGN;
terminal String PLUS_PLUS, MINUS_MINUS;
terminal String PLUS_EQ, MINUS_EQ, MULT_EQ, DIV_EQ, MOD_EQ;
terminal String ASSIGN, EQ, NEQ, GT, LT, GTE, LTE;
terminal String AND, OR, NOT, AMPERSAND;
terminal String QUESTION, COLON, ELVIS;
terminal String DOT;
terminal String IF, ELSE, SWITCH, CASE, DEFAULT, WHILE, FOR, DO, BREAK, CONTINUE, RETURN;
terminal String INT, FLOAT, CHAR, STRING;
terminal String CAST_INT, CAST_FLOAT, CAST_CHAR;
terminal String ID, INT_CONST, FLOAT_CONST, CHAR_CONST, STRING_CONST;
terminal String PRINT;
terminal String LENGTH;

// No-Terminales
non terminal Program Program;
non terminal SentenceList sentenceList;
non terminal Node sentence;
non terminal Expression expression;
non terminal Condition condition;

// Precedencias
precedence left IF;
precedence left ELSE;
precedence left ASSIGN;
precedence left ELVIS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NEQ, GT, LT, GTE, LTE;
precedence left OR;
precedence left AND;
precedence left NOT, AMPERSAND;
precedence left PLUS_PLUS, MINUS_MINUS;
precedence left PLUS_EQ, MINUS_EQ, MULT_EQ, DIV_EQ, MOD_EQ;
precedence nonassoc MINUS_SIGN;
precedence nonassoc O_PAR, C_PAR;
precedence nonassoc O_BRACK, C_BRACK;


// Gram√°tica
Program ::= sentenceList:sl {:
    RESULT = new Program(sl);
    PLXC.out.print(RESULT.gen());
  :}
  ;

sentenceList ::= sentence:s {:
    List<Node> l = new ArrayList<Node>();
    l.add(s);
    RESULT = new SentenceList(l);
  :}
  | sentenceList:sl sentence:s {:
    sl.add(s);
    RESULT = sl;
  :}
  ;

sentence ::= expression:e SEMICOLON {:
    RESULT = e;
  :}
  | IF O_PAR condition:c C_PAR sentence:s %prec IF
  | IF O_PAR condition:c C_PAR sentence:s1 ELSE sentence:s2 %prec ELSE
  | WHILE O_PAR condition C_PAR sentence
  | DO sentence WHILE O_PAR condition C_PAR SEMICOLON
  | FOR O_PAR expression SEMICOLON condition SEMICOLON expression C_PAR sentence
  | PRINT O_PAR expression:e C_PAR SEMICOLON 
  | O_CURL sentenceList:s C_CURL 
  ;

expression ::= expression:e1 PLUS expression:e2 {:
    RESULT = new BinaryArithmetic(e1, e2, "+");
  :}
  | expression:e1 MINUS expression:e2 {:
    RESULT = new BinaryArithmetic(e1, e2, "-");
  :}
  | expression:e1 MULT expression:e2 {:
    RESULT = new BinaryArithmetic(e1, e2, "*");
  :}
  | expression:e1 DIV expression:e2 {:
    RESULT = new BinaryArithmetic(e1, e2, "/");
  :}
  | MINUS expression:e %prec MINUS_SIGN {:
    RESULT = new UnaryMinus(e);
  :}
  | O_PAR expression:e C_PAR {:
    RESULT = e;
  :}
  | ID:id ASSIGN expression:e {:
    RESULT = new Assignment(id, e);
  :}
  | ID:id {:
    RESULT = new Identifier(id);
  :}
  | INT_CONST:c {:
    RESULT = new NumericLiteral(c);
  :}
  ;

condition ::= expression:e1 EQ expression:e2 {:
    RESULT = new BinaryCondition(e1, e2, "==");
  :}
  | expression:e1 NEQ expression:e2 {:
    RESULT = new BinaryCondition(e1, e2, "!=");
  :}
  | expression:e1 GT expression:e2 {:
    RESULT = new BinaryCondition(e1, e2, ">");
  :}
  | expression:e1 LT expression:e2 {:
    RESULT = new BinaryCondition(e1, e2, "<");
  :}
  | expression:e1 GTE expression:e2
  | expression:e1 LTE expression:e2
  | NOT condition:c
  | condition:c1 OR condition:c2
  | condition:c1 AND condition:c2
  | O_PAR condition:c C_PAR {:
    RESULT = c;
  :}
  ;
